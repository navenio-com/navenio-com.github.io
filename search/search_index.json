{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Navenio Android documentation Layout Select relevant section on the left to view documentation. Contact For more information about us visit our website .","title":"Welcome to Navenio Android documentation"},{"location":"#welcome-to-navenio-android-documentation","text":"","title":"Welcome to Navenio Android documentation"},{"location":"#layout","text":"Select relevant section on the left to view documentation.","title":"Layout"},{"location":"#contact","text":"For more information about us visit our website .","title":"Contact"},{"location":"SDK%20Demo%20App/SDK_1_Kotlin/","text":"Navenio SDK Kotlin Note that these instructions were created for the old sdk a while ago. Keeping in case we want to reuse some contents / structure when we create samples for the new sdk The Navenio Android SDK provides an API for developers to create location aware apps for navigation inside buildings. Setup 1) Add API for Navenio SDK and Mapbox to dependencies in build.gradle (module) It should look like this: dependencies { api \"com.navenio.dcm:sdk:1.0.49_debug\" api 'com.mapbox.mapboxsdk:mapbox-android-sdk:8.0.1' // Rest of Your dependencies } 2) Add artifactory to project's build.gradle You'll need to add artifactory, jfrog plugin, build info extractor and jitpack repository to project's build.gradle for Navenio SDK to work. Here's how to do it: dependencies { classpath \"org.jfrog.buildinfo:build-info-extractor-gradle:4.9.10\" ... } allprojects { repositories { ... maven { url \"https://jitpack.io\" } } apply plugin: 'com.jfrog.artifactory' } artifactory { contextUrl = artifactory_url resolve { // remote repo key at https://navenio.jfrog.io/navenio repoKey = 'gradle-dev' username = artifactory_username password = artifactory_password maven = true } } Creating the Navenio Manager The first step in your code is to create an instance of the Navenio Manager: val navenioManager: DebugNavenioManager= NavenioManagerProvider.getInstance(this) Fetching a venue With Navenio Manager crated, You can fetch maps with all the settings using fetchVenue command : navenioManager.fetchVenue(\"naveniohq\", object : FetchVenueListener { override fun onError(e: Throwable, cached: Venue?) { Timber.e(\"Error fetching the venue $e\") } override fun onSuccess(venue: Venue) { Timber.d(\"Venue fetched successfully!\") } }) After success, You'll receive Venue object. You can also use navenioManager.fetchVenue(\"naveniohq\") without listener, but that way You won't have any control on the process. When venue is already fetched, and You need to get venue object (e.g from different place in app), You can use navenioManager.getVenue(\"naveniohq\") , so that You're not fetching all config files and zips from server, but using venue object that is already saved locally. Getting your location Create a listener to receive callbacks from the location engine when your position has changed: val locationListener = object : LocationListenerAdapter() { override fun onLocationChange(location: Location) { when (location) { is Location.IndoorLocation -> { // Location is inside the venue } is Location.GeoLocation -> { // Location is outside the venue } } } } This listener should be registered / unregistered in the onResume and onPause Android lifecycle callbacks: override fun onResume(){ navenioManager.addLocationListener(locationListener) } override fun onPause(){ navenioManager.removeLocationListener() } You can start or stop locating anywhere in Your code by using navenioManager.startLocating(LocationModeRequest.IOD(venueID)) and navenioManager.stopLocating() . Collecting the data For data collection You'll just need to use navenioManager.startSampling(ctrl: Ctrl, venue: Venue) . You received venue object after You fetched venue, and ctrl is one of the venue fields. You can use navenioManager.stopSampling() anytime to stop current sampling session. If You want to listen for sampling change events, consider using DCMLifecycleListener. Here's example: val lifecycleListener = object : DCMLifecycleListenerAdapter() { override fun onSamplingStateChange(event: SamplingChangeEvent, sessionId: String) { when(event){ SamplingChangeEvent.START ->{ // Do something when sampling has started } SamplingChangeEvent.STOP ->{ // Do something when sampling has stopped } } } } navenioManager.addLifecycleListener(lifecycleListener) Don't forget about removing lifecycle listener after You're finished! Uploading the data There are two ways for uploading the collected data, one is just using navenioManager.upload() as it is. You have no control over it, as upload just will run in the background. Second approach(recommended) is using upload method with upload listener. Here's example: navenioManager.upload(FileUpload(), object : UploadListener { override fun onComplete() { Timber.d(\"Yay! Upload completed successfully\") } override fun onError(e: Throwable) { Timber.e(\"Something's wrong $e\") } override fun onProgress(currentIndex: Int, currentProgress: Int, max: Int) { Timber.d(\"Upload progress: $currentProgress\") } override fun onUploadStarted(filesToUpload: List<UploadFileSummary>) { Timber.d(\"Upload started!\") } }) Deleting the data // Delete all files navenioManager.deleteAllFiles() //Delete specific file navenioManager.deleteFile(file: File) Getting data summary // Receive number of files ready to upload navenioManager.getNumberOfFiles() // Receive size of files ready to upload in MB, KB or B private fun getSizeOfFiles(): String { val sizeInBytes = navenioManager.getSizeOfFiles() val properSize = when { sizeInBytes >= SDKConstants.MB_TO_BYTES -> \"${sizeInBytes / SDKConstants.MB_TO_BYTES} MB\" sizeInBytes >= SDKConstants.KB_TO_BYTES -> \"${sizeInBytes / SDKConstants.KB_TO_BYTES} KB\" else -> \"$sizeInBytes B\" } return properSize } // You can even observe a list of files, as filenameList is livedata navenioManager.filenameList.observe(this, Observer { // Do something when list is modified }) Listeners With Navenio Manager You can listen for all sorts of events. Here are some examples: // Sampling data are events such as WifiData, BatteryData, CellTowerData etc. val samplingListener = object: SamplingListener<SamplingEvent.DataEvent>(){ override fun onEvent(event: SamplingEvent.DataEvent) { // Do something with Your event } } navenioManager.addDataEventListener(samplingListener) // Diagnostic data are events such as WifISamplingStarted, GPSError, GPSStatusChanged etc. val diagnosticListener= object: SamplingListener<SamplingEvent.DiagnosticEvent>(){ override fun onEvent(event: SamplingEvent.DiagnosticEvent) { // Do something with Your event } } navenioManager.addDiagnosticEventListener(diagnosticListener) Login .login function is now a coroutine, must be called properly: import kotlinx.coroutines.CoroutineScope import kotlinx.coroutines.Dispatchers import kotlinx.coroutines.launch class LoginActivity : AppCompatActivity() { private val scope = CoroutineScope(Dispatchers.Main) scope.launch{doLogin()} suspend fun doLogin(username: String, password: String) {...} }","title":"Navenio SDK Kotlin"},{"location":"SDK%20Demo%20App/SDK_1_Kotlin/#navenio-sdk-kotlin","text":"Note that these instructions were created for the old sdk a while ago. Keeping in case we want to reuse some contents / structure when we create samples for the new sdk The Navenio Android SDK provides an API for developers to create location aware apps for navigation inside buildings.","title":"Navenio SDK Kotlin"},{"location":"SDK%20Demo%20App/SDK_1_Kotlin/#setup","text":"","title":"Setup"},{"location":"SDK%20Demo%20App/SDK_1_Kotlin/#1-add-api-for-navenio-sdk-and-mapbox-to-dependencies-in-buildgradle-module","text":"It should look like this: dependencies { api \"com.navenio.dcm:sdk:1.0.49_debug\" api 'com.mapbox.mapboxsdk:mapbox-android-sdk:8.0.1' // Rest of Your dependencies }","title":"1) Add API for Navenio SDK and Mapbox to dependencies in build.gradle (module)"},{"location":"SDK%20Demo%20App/SDK_1_Kotlin/#2-add-artifactory-to-projects-buildgradle","text":"You'll need to add artifactory, jfrog plugin, build info extractor and jitpack repository to project's build.gradle for Navenio SDK to work. Here's how to do it: dependencies { classpath \"org.jfrog.buildinfo:build-info-extractor-gradle:4.9.10\" ... } allprojects { repositories { ... maven { url \"https://jitpack.io\" } } apply plugin: 'com.jfrog.artifactory' } artifactory { contextUrl = artifactory_url resolve { // remote repo key at https://navenio.jfrog.io/navenio repoKey = 'gradle-dev' username = artifactory_username password = artifactory_password maven = true } }","title":"2) Add artifactory to project's build.gradle"},{"location":"SDK%20Demo%20App/SDK_1_Kotlin/#creating-the-navenio-manager","text":"The first step in your code is to create an instance of the Navenio Manager: val navenioManager: DebugNavenioManager= NavenioManagerProvider.getInstance(this)","title":"Creating the Navenio Manager"},{"location":"SDK%20Demo%20App/SDK_1_Kotlin/#fetching-a-venue","text":"With Navenio Manager crated, You can fetch maps with all the settings using fetchVenue command : navenioManager.fetchVenue(\"naveniohq\", object : FetchVenueListener { override fun onError(e: Throwable, cached: Venue?) { Timber.e(\"Error fetching the venue $e\") } override fun onSuccess(venue: Venue) { Timber.d(\"Venue fetched successfully!\") } }) After success, You'll receive Venue object. You can also use navenioManager.fetchVenue(\"naveniohq\") without listener, but that way You won't have any control on the process. When venue is already fetched, and You need to get venue object (e.g from different place in app), You can use navenioManager.getVenue(\"naveniohq\") , so that You're not fetching all config files and zips from server, but using venue object that is already saved locally.","title":"Fetching a venue"},{"location":"SDK%20Demo%20App/SDK_1_Kotlin/#getting-your-location","text":"Create a listener to receive callbacks from the location engine when your position has changed: val locationListener = object : LocationListenerAdapter() { override fun onLocationChange(location: Location) { when (location) { is Location.IndoorLocation -> { // Location is inside the venue } is Location.GeoLocation -> { // Location is outside the venue } } } } This listener should be registered / unregistered in the onResume and onPause Android lifecycle callbacks: override fun onResume(){ navenioManager.addLocationListener(locationListener) } override fun onPause(){ navenioManager.removeLocationListener() } You can start or stop locating anywhere in Your code by using navenioManager.startLocating(LocationModeRequest.IOD(venueID)) and navenioManager.stopLocating() .","title":"Getting your location"},{"location":"SDK%20Demo%20App/SDK_1_Kotlin/#collecting-the-data","text":"For data collection You'll just need to use navenioManager.startSampling(ctrl: Ctrl, venue: Venue) . You received venue object after You fetched venue, and ctrl is one of the venue fields. You can use navenioManager.stopSampling() anytime to stop current sampling session. If You want to listen for sampling change events, consider using DCMLifecycleListener. Here's example: val lifecycleListener = object : DCMLifecycleListenerAdapter() { override fun onSamplingStateChange(event: SamplingChangeEvent, sessionId: String) { when(event){ SamplingChangeEvent.START ->{ // Do something when sampling has started } SamplingChangeEvent.STOP ->{ // Do something when sampling has stopped } } } } navenioManager.addLifecycleListener(lifecycleListener) Don't forget about removing lifecycle listener after You're finished!","title":"Collecting the data"},{"location":"SDK%20Demo%20App/SDK_1_Kotlin/#uploading-the-data","text":"There are two ways for uploading the collected data, one is just using navenioManager.upload() as it is. You have no control over it, as upload just will run in the background. Second approach(recommended) is using upload method with upload listener. Here's example: navenioManager.upload(FileUpload(), object : UploadListener { override fun onComplete() { Timber.d(\"Yay! Upload completed successfully\") } override fun onError(e: Throwable) { Timber.e(\"Something's wrong $e\") } override fun onProgress(currentIndex: Int, currentProgress: Int, max: Int) { Timber.d(\"Upload progress: $currentProgress\") } override fun onUploadStarted(filesToUpload: List<UploadFileSummary>) { Timber.d(\"Upload started!\") } })","title":"Uploading the data"},{"location":"SDK%20Demo%20App/SDK_1_Kotlin/#deleting-the-data","text":"// Delete all files navenioManager.deleteAllFiles() //Delete specific file navenioManager.deleteFile(file: File)","title":"Deleting the data"},{"location":"SDK%20Demo%20App/SDK_1_Kotlin/#getting-data-summary","text":"// Receive number of files ready to upload navenioManager.getNumberOfFiles() // Receive size of files ready to upload in MB, KB or B private fun getSizeOfFiles(): String { val sizeInBytes = navenioManager.getSizeOfFiles() val properSize = when { sizeInBytes >= SDKConstants.MB_TO_BYTES -> \"${sizeInBytes / SDKConstants.MB_TO_BYTES} MB\" sizeInBytes >= SDKConstants.KB_TO_BYTES -> \"${sizeInBytes / SDKConstants.KB_TO_BYTES} KB\" else -> \"$sizeInBytes B\" } return properSize } // You can even observe a list of files, as filenameList is livedata navenioManager.filenameList.observe(this, Observer { // Do something when list is modified })","title":"Getting data summary"},{"location":"SDK%20Demo%20App/SDK_1_Kotlin/#listeners","text":"With Navenio Manager You can listen for all sorts of events. Here are some examples: // Sampling data are events such as WifiData, BatteryData, CellTowerData etc. val samplingListener = object: SamplingListener<SamplingEvent.DataEvent>(){ override fun onEvent(event: SamplingEvent.DataEvent) { // Do something with Your event } } navenioManager.addDataEventListener(samplingListener) // Diagnostic data are events such as WifISamplingStarted, GPSError, GPSStatusChanged etc. val diagnosticListener= object: SamplingListener<SamplingEvent.DiagnosticEvent>(){ override fun onEvent(event: SamplingEvent.DiagnosticEvent) { // Do something with Your event } } navenioManager.addDiagnosticEventListener(diagnosticListener)","title":"Listeners"},{"location":"SDK%20Demo%20App/SDK_1_Kotlin/#login","text":".login function is now a coroutine, must be called properly: import kotlinx.coroutines.CoroutineScope import kotlinx.coroutines.Dispatchers import kotlinx.coroutines.launch class LoginActivity : AppCompatActivity() { private val scope = CoroutineScope(Dispatchers.Main) scope.launch{doLogin()} suspend fun doLogin(username: String, password: String) {...} }","title":"Login"},{"location":"SDK%20Demo%20App/SDK_2_Java/","text":"Navenio SDK Java Dependencies & Gradle Add to app-level build.gradle file, same as Kotlin. Make sure the SDK version is correct (eg 2020-02-26_10-20-22_debug, 2021-01-15_13-43-50_debug): dependencies { api \"com.navenio.dcm:sdk:1.0.49_debug\" api 'com.mapbox.mapboxsdk:mapbox-android-sdk:8.0.1' ... } Build info extractor in project-level build-gradle file, same as Kotlin: dependencies { classpath \"org.jfrog.buildinfo:build-info-extractor-gradle:4.9.10\" ... } Jitpack repository + Jfrog plugin in project-level build-gradle file, same as Kotlin: allprojects { repositories { ... maven { url \"https://jitpack.io\" } } apply plugin: 'com.jfrog.artifactory' } Adding artifactory to project-level build-gradle file, same as Kotlin. Make sure to specify correct url, user and pass variables. Can set these up in separate file, like gradle.properties: artifactory { contextUrl = artifactory_url resolve { repoKey = 'gradle-dev' username = artifactory_username password = artifactory_password maven = true } } Need to prepare Java project for Kotlin. In AS can use steps: Tools > Kotlin > Configure Kotlin in Project > select module and Kotlin version. Used 1.3.50 in example. Or can manually edit app-level build.gradle file with: apply plugin: 'kotlin-android-extensions' apply plugin: 'kotlin-android' dependencies { ... implementation \"androidx.core:core-ktx:+\" implementation \"org.jetbrains.kotlin:kotlin-stdlib-jdk7:$kotlin_version\" } repositories { mavenCentral() } And project-level build-gradle file with: buildscript { ... ext.kotlin_version = '1.3.50' } dependencies { ... classpath \"org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version\" } Java 8 required to run SDK. Modify compileOptions with above: android { compileOptions { sourceCompatibility 1.8 targetCompatibility 1.8 } } SDK calls The first step, Navenio manager instantiated like this: navenioManager = NavenioManagerProvider.Companion.getInstance(this); ^ Note the .Companion keyword, unlike Kotlin. To login: navenioManager.login(username, password, authListener); Credentials are String, authListener is AuthListener object. Can manage it using LiveData: MutableLiveData<AuthResponse> loginResult = new MutableLiveData<>(); and AuthListener authListener = new AuthListener() { @Override public void onSuccess(AuthResponse response) { if (response != null) { loginResult.postValue(response); } ... .login is coroutine now. Continuation object of <? super kotlin.Unit> type is required in navenioManager.login(username, password, authListener, Continuation) Observing AuthResponse changes: loginResult.observe(this, new Observer<AuthResponse>() { @Override public void onChanged(AuthResponse authResponse) { if (authResponse != null) { loginSuccess(authResponse); } ... } }); On successful login save authentication to preferences, like: private void saveAuthToken (AuthResponse authResponse, String username) { authResponse.setUsername(username); prefs.edit().putString(LOGIN_USER_HANDLE, gson.toJson(authResponse)).apply(); } To get Venue object: navenioManager.fetchVenue(VENUE, new FetchVenueListener() { @Override public void onSuccess (@NotNull Venue venue) { this.venue = venue; ... } @Override public void onError (@NotNull Throwable error, Venue cached) { Timber.e(error); ... } }); Use navenioManager.getVenue(VENUE); to get venue that was already downloaded. To get your location create listener: locationListener = new LocationListenerAdapter() { @Override public void onLocationChange (@NotNull Location location) { if (location instanceof Location.IndoorLocation) { // inside venue } else if (location instanceof Location.GeoLocation) { // outside venue } } }; Should register/unregister at certain lifecycle callbacks: locationManager.addLocationListener(locationListener); locationManager.removeLocationListener(locationListener); To start or stop locating: locationManager.startLocating(new LocationModeRequest.IOD(VENUE.getVenue_id(), true), null); locationManager.stopLocating(); To start or stop sampling: navenioManager.startSampling(venue.getCtrl(), venue); navenioManager.stopSampling(); To update on sampling state use listner: lifecycleListener = new DCMLifecycleListenerAdapter() { @Override public void onSamplingStateChange(@NotNull SamplingChangeEvent event, @NotNull String sessionId) { ... } }; Check if sampling: navenioManager.isSampling(); Attach and remove listener at necessary lifecycle stages: navenioManager.addLifecycleListener(lifecycleListener); navenioManager.removeLifecycleListener(lifecycleListener); Uploading files using a listner: navenioManager.upload(new UploadListener(){ @Override public void onUploadStarted(@NotNull List<UploadFileSummary> filesToUpload) { ... } @Override public void onProgress(int currentIndex, int currentProgress, int max) { ... } @Override public void onError(@NotNull Throwable e) { Timber.e(e); ... } @Override public void onComplete() { ... } }); Need to call FileUpload() along with UploadListener() : public void uploadFiles (View view) { locationManager.upload(new FileUpload(), new UploadListener(){ @Override public void onUploadStarted(.... Deleting all files: navenioManager.deleteAllFiles(); Getting the total number of files: navenioManager.getNumberOfFiles(); Getting the total size of files in different measurement units like this: private String getSizeOfFiles () { long sizeInBytes = navenioManager.getSizeOfFiles(); String properSize; if (sizeInBytes >= SDKConstants.MB_TO_BYTES) { properSize = sizeInBytes/SDKConstants.MB_TO_BYTES + \"MB\"; } else if (sizeInBytes >= SDKConstants.KB_TO_BYTES) { properSize = sizeInBytes/SDKConstants.KB_TO_BYTES + \"KB\"; } else { properSize = sizeInBytes + \"B\"; } return properSize; } Notes: Min SDK level is now 26, specify in app build.gradle. Default arguments not supported in Java. Some Kotlin classes in SDK have default arguments. E.g. fun startSampling(ctrl: Ctrl, venue: Venue? = null) in DataCollectionModule.kt import org.jetbrains.anko.runOnUiThread seems to be deprecated in Kotlin app.","title":"Navenio SDK Java"},{"location":"SDK%20Demo%20App/SDK_2_Java/#navenio-sdk-java","text":"","title":"Navenio SDK Java"},{"location":"SDK%20Demo%20App/SDK_2_Java/#dependencies-gradle","text":"Add to app-level build.gradle file, same as Kotlin. Make sure the SDK version is correct (eg 2020-02-26_10-20-22_debug, 2021-01-15_13-43-50_debug): dependencies { api \"com.navenio.dcm:sdk:1.0.49_debug\" api 'com.mapbox.mapboxsdk:mapbox-android-sdk:8.0.1' ... } Build info extractor in project-level build-gradle file, same as Kotlin: dependencies { classpath \"org.jfrog.buildinfo:build-info-extractor-gradle:4.9.10\" ... } Jitpack repository + Jfrog plugin in project-level build-gradle file, same as Kotlin: allprojects { repositories { ... maven { url \"https://jitpack.io\" } } apply plugin: 'com.jfrog.artifactory' } Adding artifactory to project-level build-gradle file, same as Kotlin. Make sure to specify correct url, user and pass variables. Can set these up in separate file, like gradle.properties: artifactory { contextUrl = artifactory_url resolve { repoKey = 'gradle-dev' username = artifactory_username password = artifactory_password maven = true } } Need to prepare Java project for Kotlin. In AS can use steps: Tools > Kotlin > Configure Kotlin in Project > select module and Kotlin version. Used 1.3.50 in example. Or can manually edit app-level build.gradle file with: apply plugin: 'kotlin-android-extensions' apply plugin: 'kotlin-android' dependencies { ... implementation \"androidx.core:core-ktx:+\" implementation \"org.jetbrains.kotlin:kotlin-stdlib-jdk7:$kotlin_version\" } repositories { mavenCentral() } And project-level build-gradle file with: buildscript { ... ext.kotlin_version = '1.3.50' } dependencies { ... classpath \"org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version\" } Java 8 required to run SDK. Modify compileOptions with above: android { compileOptions { sourceCompatibility 1.8 targetCompatibility 1.8 } }","title":"Dependencies &amp; Gradle"},{"location":"SDK%20Demo%20App/SDK_2_Java/#sdk-calls","text":"","title":"SDK calls"},{"location":"SDK%20Demo%20App/SDK_2_Java/#the-first-step-navenio-manager-instantiated-like-this","text":"navenioManager = NavenioManagerProvider.Companion.getInstance(this); ^ Note the .Companion keyword, unlike Kotlin.","title":"The first step, Navenio manager instantiated like this:"},{"location":"SDK%20Demo%20App/SDK_2_Java/#to-login","text":"navenioManager.login(username, password, authListener); Credentials are String, authListener is AuthListener object. Can manage it using LiveData: MutableLiveData<AuthResponse> loginResult = new MutableLiveData<>(); and AuthListener authListener = new AuthListener() { @Override public void onSuccess(AuthResponse response) { if (response != null) { loginResult.postValue(response); } ... .login is coroutine now. Continuation object of <? super kotlin.Unit> type is required in navenioManager.login(username, password, authListener, Continuation)","title":"To login:"},{"location":"SDK%20Demo%20App/SDK_2_Java/#observing-authresponse-changes","text":"loginResult.observe(this, new Observer<AuthResponse>() { @Override public void onChanged(AuthResponse authResponse) { if (authResponse != null) { loginSuccess(authResponse); } ... } });","title":"Observing AuthResponse changes:"},{"location":"SDK%20Demo%20App/SDK_2_Java/#on-successful-login-save-authentication-to-preferences-like","text":"private void saveAuthToken (AuthResponse authResponse, String username) { authResponse.setUsername(username); prefs.edit().putString(LOGIN_USER_HANDLE, gson.toJson(authResponse)).apply(); }","title":"On successful login save authentication to preferences, like:"},{"location":"SDK%20Demo%20App/SDK_2_Java/#to-get-venue-object","text":"navenioManager.fetchVenue(VENUE, new FetchVenueListener() { @Override public void onSuccess (@NotNull Venue venue) { this.venue = venue; ... } @Override public void onError (@NotNull Throwable error, Venue cached) { Timber.e(error); ... } }); Use navenioManager.getVenue(VENUE); to get venue that was already downloaded.","title":"To get Venue object:"},{"location":"SDK%20Demo%20App/SDK_2_Java/#to-get-your-location-create-listener","text":"locationListener = new LocationListenerAdapter() { @Override public void onLocationChange (@NotNull Location location) { if (location instanceof Location.IndoorLocation) { // inside venue } else if (location instanceof Location.GeoLocation) { // outside venue } } };","title":"To get your location create listener:"},{"location":"SDK%20Demo%20App/SDK_2_Java/#should-registerunregister-at-certain-lifecycle-callbacks","text":"locationManager.addLocationListener(locationListener); locationManager.removeLocationListener(locationListener);","title":"Should register/unregister at certain lifecycle callbacks:"},{"location":"SDK%20Demo%20App/SDK_2_Java/#to-start-or-stop-locating","text":"locationManager.startLocating(new LocationModeRequest.IOD(VENUE.getVenue_id(), true), null); locationManager.stopLocating();","title":"To start or stop locating:"},{"location":"SDK%20Demo%20App/SDK_2_Java/#to-start-or-stop-sampling","text":"navenioManager.startSampling(venue.getCtrl(), venue); navenioManager.stopSampling();","title":"To start or stop sampling:"},{"location":"SDK%20Demo%20App/SDK_2_Java/#to-update-on-sampling-state-use-listner","text":"lifecycleListener = new DCMLifecycleListenerAdapter() { @Override public void onSamplingStateChange(@NotNull SamplingChangeEvent event, @NotNull String sessionId) { ... } };","title":"To update on sampling state use listner:"},{"location":"SDK%20Demo%20App/SDK_2_Java/#check-if-sampling","text":"navenioManager.isSampling();","title":"Check if sampling:"},{"location":"SDK%20Demo%20App/SDK_2_Java/#attach-and-remove-listener-at-necessary-lifecycle-stages","text":"navenioManager.addLifecycleListener(lifecycleListener); navenioManager.removeLifecycleListener(lifecycleListener);","title":"Attach and remove listener at necessary lifecycle stages:"},{"location":"SDK%20Demo%20App/SDK_2_Java/#uploading-files-using-a-listner","text":"navenioManager.upload(new UploadListener(){ @Override public void onUploadStarted(@NotNull List<UploadFileSummary> filesToUpload) { ... } @Override public void onProgress(int currentIndex, int currentProgress, int max) { ... } @Override public void onError(@NotNull Throwable e) { Timber.e(e); ... } @Override public void onComplete() { ... } }); Need to call FileUpload() along with UploadListener() : public void uploadFiles (View view) { locationManager.upload(new FileUpload(), new UploadListener(){ @Override public void onUploadStarted(....","title":"Uploading files using a listner:"},{"location":"SDK%20Demo%20App/SDK_2_Java/#deleting-all-files","text":"navenioManager.deleteAllFiles();","title":"Deleting all files:"},{"location":"SDK%20Demo%20App/SDK_2_Java/#getting-the-total-number-of-files","text":"navenioManager.getNumberOfFiles();","title":"Getting the total number of files:"},{"location":"SDK%20Demo%20App/SDK_2_Java/#getting-the-total-size-of-files-in-different-measurement-units-like-this","text":"private String getSizeOfFiles () { long sizeInBytes = navenioManager.getSizeOfFiles(); String properSize; if (sizeInBytes >= SDKConstants.MB_TO_BYTES) { properSize = sizeInBytes/SDKConstants.MB_TO_BYTES + \"MB\"; } else if (sizeInBytes >= SDKConstants.KB_TO_BYTES) { properSize = sizeInBytes/SDKConstants.KB_TO_BYTES + \"KB\"; } else { properSize = sizeInBytes + \"B\"; } return properSize; }","title":"Getting the total size of files in different measurement units like this:"},{"location":"SDK%20Demo%20App/SDK_2_Java/#notes","text":"Min SDK level is now 26, specify in app build.gradle. Default arguments not supported in Java. Some Kotlin classes in SDK have default arguments. E.g. fun startSampling(ctrl: Ctrl, venue: Venue? = null) in DataCollectionModule.kt import org.jetbrains.anko.runOnUiThread seems to be deprecated in Kotlin app.","title":"Notes:"}]}